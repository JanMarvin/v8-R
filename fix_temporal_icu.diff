diff --git a/src/objects/js-temporal-zoneinfo64.cc b/src/objects/js-temporal-zoneinfo64.cc
index 99dd3a84c1e..8e45daf02e8 100644
--- a/src/objects/js-temporal-zoneinfo64.cc
+++ b/src/objects/js-temporal-zoneinfo64.cc
@@ -10,46 +10,16 @@
 #include "temporal_rs/Provider.hpp"
 #include "temporal_rs/TimeZone.hpp"
 
-#ifdef V8_INTL_SUPPORT
-#include "udatamem.h"
-#else
 // Defined in builtins-temporal-zoneinfo64-data.cc, generated by
 // include-file-as-bytes.py
 extern "C" uint32_t zoneinfo64_static_data[];
 extern "C" size_t zoneinfo64_static_data_len;
-#endif
 
 namespace v8::internal {
 
 ZoneInfo64Provider::ZoneInfo64Provider() {
-#ifdef V8_INTL_SUPPORT
-  UErrorCode status = U_ZERO_ERROR;
-  memory = udata_open(0, "res", "zoneinfo64", &status);
-  if (U_FAILURE(status)) {
-    DCHECK_WITH_MSG(false, "Failed to open zoneinfo64.res");
-    provider = temporal_rs::Provider::empty();
-    return;
-  }
-  // NOT udata_getLength: this ignores the header,
-  // and we're parsing resb files with the header
-  auto length = memory->length;
-  const void* data = udata_getRawMemory(memory);
-  DCHECK_WITH_MSG(length % 4 == 0, "ICU4C should align udata to uint32_t");
-  if (length % 4 != 0) {
-    // This really shouldn't happen: ICU4C aligns these files
-    // to 4 when baking them in
-    provider = temporal_rs::Provider::empty();
-    return;
-  }
-
-  const uint32_t* data_32 = static_cast<const uint32_t*>(data);
-  std::span<const uint32_t> data_span(data_32, length / 4);
-
-#else
   std::span<const uint32_t> data_span(zoneinfo64_static_data,
                                       zoneinfo64_static_data_len);
-#endif
-
   auto result = temporal_rs::Provider::new_zoneinfo64(data_span);
   DCHECK_WITH_MSG(result.is_ok(), "Baked-in zoneinfo64 file must parse");
   if (result.is_ok()) {
@@ -74,11 +44,6 @@ ZoneInfo64Provider::~ZoneInfo64Provider() {
 
   // Then clean up memory
   // This ideally is a no-op when using static data
-#ifdef V8_INTL_SUPPORT
-  if (memory) {
-    udata_close(memory);
-  }
-#endif
 }
 
 }  // namespace v8::internal
diff --git a/src/objects/js-temporal-zoneinfo64.h b/src/objects/js-temporal-zoneinfo64.h
index 723f2162a82..4c80a3c2194 100644
--- a/src/objects/js-temporal-zoneinfo64.h
+++ b/src/objects/js-temporal-zoneinfo64.h
@@ -7,11 +7,7 @@
 
 #include "temporal_rs/Provider.d.hpp"
 
-#ifdef V8_INTL_SUPPORT
-#include "unicode/udata.h"
-#else
 #include <vector>
-#endif
 
 namespace v8::internal {
 
@@ -37,9 +33,6 @@ class ZoneInfo64Provider {
   ZoneInfo64Provider();
   ~ZoneInfo64Provider();
   std::unique_ptr<temporal_rs::Provider> provider;
-#ifdef V8_INTL_SUPPORT
-  UDataMemory* memory;
-#endif
 };
 
 }  // namespace v8::internal
diff --git a/BUILD.gn b/BUILD.gn
index 52a9c860841..c05c4182b7f 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -6526,7 +6532,7 @@ v8_source_set("v8_base_without_compiler") {
 
   # In i18n mode, we can use ICU4C to load ICU4C's builtin zoneinfo64.res data
   # In non-i18n mode, we need to copy that into the binary
-  if (v8_enable_temporal_support && !v8_enable_i18n_support) {
+  if (v8_enable_temporal_support) {
     sources +=
         [ "$target_gen_dir/src/builtins/builtins-temporal-zoneinfo64-data.cc" ]
     deps += [ ":make_temporal_zoneinfo_cpp" ]
